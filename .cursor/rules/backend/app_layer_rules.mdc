---
globs: backend/apps/**/*.py
description: App layer (API) contract for FastAPI endpoints in backend/apps. Parse/validate input, call services, map domain errors to HTTP, return JSONResponse on success.
---

### Purpose and Scope

- The App layer is the HTTP boundary for the backend. It applies to files under `backend/apps/*.py`.
- Responsibilities:
  - Parse and validate HTTP inputs.
  - Call underlying services; do not implement core business logic here.
  - Translate domain/service exceptions into `HTTPException` with proper status codes.
  - Return `JSONResponse(status_code=HTTPStatus.OK, content=payload)` on success.
- Configuration: Do not access environment variables directly. Read configuration via `consts.const` or pass values through from the request to services.

References: [backend/consts/exceptions.py](mdc:backend/consts/exceptions.py)

### Routing and URL Design

- Keep existing top-level prefixes for compatibility (e.g., `"/agent"`, `"/memory"`). When adding new modules or endpoints, follow these rules:
  - Use plural nouns for collection-style resources (e.g., `"/agents"`, `"/memories"`).
  - Use snake_case for all path segments. Avoid hyphens and camelCase.
  - Prefer resource-oriented paths for CRUD-style operations. Example: `"/agents"` (collection), `"/agents/{agent_id}"` (single resource).
  - Use action-style paths only when necessary to match current patterns or when the operation is not naturally CRUD (e.g., `"/agent/run"`, `"/agent/stop/{conversation_id}"`).
  - Path parameters must be singular, semantic nouns: `"/agents/{agent_id}"`, `"/memories/{memory_id}"`.
  - Keep backwards compatibility: do not rename existing routes; new routes should follow these conventions.

### HTTP Methods

- GET: Read and list operations only. Maintain existing special cases where GET performs safe actions (e.g., `GET /agent/stop/{conversation_id}`), but do not introduce new side-effecting GETs.
- POST: Create resources, perform searches, or trigger actions with side effects (e.g., `POST /memory/add`, `POST /memory/search`, `POST /agent/run`).
- DELETE: Delete resources or clear collections (e.g., `DELETE /memory/clear`). Ensure idempotency.
- PUT/PATCH: Update resources. Prefer `PUT` for full updates and `PATCH` for partial updates. Preserve legacy `POST /update` endpoints for compatibility but favor PUT/PATCH for new code.

### Authorization and Identity

- Retrieve the bearer token via header injection: `authorization: Optional[str] = Header(None)`.
- Use utility helpers to parse identity (prefer functions in `utils.auth_utils`, such as `get_current_user_id` or `get_current_user_info`) and pass `user_id` and/or `tenant_id` down to services. The App layer should not implement token parsing logic itself.

### Request Validation

- Prefer Pydantic models in `consts.model` as request bodies for complex payloads (e.g., `AgentRequest`).
- For simple atomic fields, use `Body(..., embed=True)` to pin the JSON key name.
- Use `Query(...)` for filters and pagination, `Path(...)` for path parameters, and `Header(...)` for headers.
- Pagination recommendations for listing endpoints: `page: int = Query(1, ge=1)`, `page_size: int = Query(20, ge=1, le=100)`, plus optional `order_by`, `filters` as appropriate. Return pagination metadata (`items`, `total`) or match existing return shapes in the codebase.

### Responses

- On success, return `JSONResponse(status_code=HTTPStatus.OK, content=payload)`.
- If a standard response model exists in the project (e.g., conversation responses), continue to use it for consistency.
- For new endpoints, return a structured content dictionary with necessary fields (e.g., `{"data": ..., "message": "OK"}`) while staying consistent with existing patterns.

### Exception Mapping

- Catch domain/service exceptions from `backend/consts/exceptions.py` and map to `HTTPException` with appropriate status codes. Examples:
  - `UnauthorizedError` → 401 UNAUTHORIZED
  - `LimitExceededError` → 429 TOO_MANY_REQUESTS
  - Parameter/validation errors (e.g., invalid enum, unknown config key) → 400 BAD_REQUEST or 406 NOT_ACCEPTABLE (follow existing precedent such as `set_single_config` using 406)
  - Unexpected errors → 500 INTERNAL_SERVER_ERROR (log the error; do not leak internal details)

### Logging and Observability

- Use a module-level logger: `logger = logging.getLogger("<module_name>")`.
- Log key events and errors. For listing/search endpoints, optionally log query scope and timing while avoiding sensitive data.

### Async/Sync Conventions

- Match the existing style in each module. Keep `async def` where already used.
- When calling async services, prefer direct `await`. When calling sync services, invoke them directly without creating new event loops.

### Backward Compatibility

- Do not break existing routes, payload shapes, or response structures.
- New endpoints should follow these conventions strictly to converge the API style across modules.

### Correct Example (parse input, call service, map exceptions, return JSONResponse)
```python
from http import HTTPStatus
import logging
from fastapi import APIRouter, HTTPException
from starlette.responses import JSONResponse

from consts.exceptions import LimitExceededError, AgentRunException, MemoryPreparationException
from services.agent_service import run_agent

logger = logging.getLogger(__name__)
router = APIRouter()

@router.post("/agent/run")
def run_agent_endpoint(payload: dict):
    try:
        result = run_agent(payload)
        return JSONResponse(status_code=HTTPStatus.OK, content=result)
    except LimitExceededError as exc:
        raise HTTPException(status_code=HTTPStatus.TOO_MANY_REQUESTS, detail=str(exc))
    except MemoryPreparationException as exc:
        raise HTTPException(status_code=HTTPStatus.BAD_REQUEST, detail=str(exc))
    except AgentRunException as exc:
        raise HTTPException(status_code=HTTPStatus.INTERNAL_SERVER_ERROR, detail=str(exc))
```

### Incorrect Example (business logic in App layer or non-HTTP error handling)
```python
from starlette.responses import JSONResponse

def run_agent_endpoint(payload: dict):
    # WRONG: performing core business logic inside the app layer
    if payload.get("force"):
        return {"status": "forced"}  # WRONG: returns plain dict without HTTP status context

    # WRONG: not translating domain errors to HTTP
    result = risky_logic(payload)
    return JSONResponse(result)
```